状态模式
1）概述
	当一个对象的内在状态改变时允许改变其行为，这个对象看起来想是改变了其类。
2）解决的问题
	主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同容得一系列类当中，可以把复杂的逻辑判断简单化。
3）模式中的角色
	3.1上下文环境(Context)：它定义了客户程序需要的接口并维护一个具体状态角色的实例。将与状态相关的操作委托给当前的ConcreteState对象来处理
	3.2抽象状态(State)：定义一个接口以封装使用上下文环境的一个特定状态相关的行为
	3.3具体状态(ConcreteState)：实现抽象状态定义的接口



2）外观模式
	一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。


3）单例模式
	含义：单例 = 一个实例
	解决的问题：降低对象之间的耦合度
	解决方法：单例模式，即实现一个类只有一个实例化对象，并提供一个全局访问点。
 优点：
	1）提供了对唯一实例的受控访问
	2）由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要要频繁创建和销毁的对象单例模式无疑可以提高系统的性能
	3）允许可变数目的实例

 缺点
	1）由于单例模式中没有抽象层，因此单例类的扩展有很大的困难
	2）单例类的职责过重，在一定程度上违背了“单一职责原则”
	3）滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。
	